// Px grammar for the Aspect Definition Language.
//
// This does not yet include white-space handling
// White space includes space, tab, newline and a comment as '//' followed by any characters to end-of-line

TOP =
	*definition

EOF =
	!.

definition =
	!EOF !'}' ?path_name body ?';'

body =
	| reference
	| alias_from
	| ?supertype ?block ?post_body

alias_from =
	'!' path_name

supertype =
	':' ?path_name

path_name =
	&(|ascend |name) ?(name *(descend name))

ascend =
	'.'

descend =
	'.'

name =
	| symbol
	| integer

// Unicode categories here: \a = any letter, \w = any letter or digit, \p{Mn} = non-spacing mark (accent)
symbol =
	[_\a] *[_\w\p{Mn}]

integer =
	[1-9] *\d

reference =
	(| '->' | '=>') path_name ?block ?assignment

block =
	'{' *definition '}'

post_body =
	| array_indicator ?assignment
	| assignment

array_indicator =
	'[]'

assignment =
	| final_assignment
	| tentative_assignment

final_assignment =
	'=' value

tentative_assignment =
	'~=' value

value =
	| atomic_value
	| array

array =
	'[' atomic_value *(',' atomic_value) ']'

// If the Variable is a Regular Expression the value is a regexp.
// If the Variable is a Reference, the value is a path_name or object literal.
// Otherwise, the value is defined by the Syntax of the variable (regexp_match).
// See builtin.adl for the syntax of values of builtin variables.
atomic_value =
	| pegexp_literal	// A regular expression
	| path_name		// A reference to another object
	| object_literal	// An inline object definition
		// This rule cannot be defined in Px so is temporarily elided here during tool development:
//	| matched_literal	// Value matches the Syntax of the variable being assigned

object_literal =
	supertype ?block ?assignment

// Above here, white-space is free. Below here, no implicit white-space is allowed.

// The syntax for a Regular Expression is not regular, so it must be built-in.
pegexp_literal =
	'/' pegexp_sequence '/'

pegexp_sequence =
	| +('|' +pegexp_atom)
	| *pegexp_atom

pegexp_atom =
	?[*+?]
	(| pegexp_lookahead
	 | pegexp_char			// including ., for any
	 | pegexp_class
	 | pegexp_group)

pegexp_group =
	'(' pegexp_sequence ')'

pegexp_lookahead =
	[&!] pegexp_atom

pegexp_char =
	| '\\'
	  (| [adhswLU]			// alpha, digit, hex, whitespace, word (alpha or digit), Lowercase, Uppercase
	   | ?[0-3] [0-7] ?[0-7]
	   | 'x' \h ?\h			// hex character, 1 or 2 digits
	   | 'x{' +\h '}'		// hex character \x{...}, arbitrary precision
	   | 'u' \h ?\h ?\h ?\h		// Unicode character 1..4 digits
	   | 'u{' +\h '}'		// Unicode character \u{...}, arbitrary precision
	   | [pP] '{' +[A-Za-z_] '}'	// Unicode named property
	   | [.0befntr\\*+?()|/\[]	// Special escapes
	  )
	| [^*+?()|/\[\0- ]		// Other non-ctl chars except pegexp operator initiators (but allow . operator)

pegexp_class =
	'[' ?'^' ?'-' +pegexp_class_part ']'

pegexp_class_part =
	| ! ']' pegexp_class_char ?('-' !']' pegexp_class_char)

pegexp_class_char =
	| !'-' pegexp_char
	| [*+?()|/]
